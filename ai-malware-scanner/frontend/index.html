<!DOCTYPE html>
<html>
<head>
    <title>AI Malware Scanner</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1000px;
            margin: 0 auto;
            padding: 20px;
        }
        .container {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        .card {
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
        }
        .result-section {
            margin-top: 20px;
            display: none;
        }
        .risk-high {
            color: #d9534f;
            font-weight: bold;
        }
        .risk-medium {
            color: #f0ad4e;
            font-weight: bold;
        }
        .risk-low {
            color: #5cb85c;
            font-weight: bold;
        }
        .button-row {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }
        button {
            padding: 10px 15px;
            background-color: #337ab7;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        button:hover {
            background-color: #286090;
        }
        button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }
        #fileInput {
            margin-bottom: 10px;
        }
        .progress-bar {
            width: 100%;
            background-color: #f3f3f3;
            border-radius: 5px;
            margin-top: 10px;
        }
        .progress {
            width: 0%;
            height: 20px;
            background-color: #4CAF50;
            border-radius: 5px;
            text-align: center;
            line-height: 20px;
            color: white;
        }
        table {
            width: 100%;
            border-collapse: collapse;
        }
        table, th, td {
            border: 1px solid #ddd;
        }
        th, td {
            padding: 8px;
            text-align: left;
        }
        th {
            background-color: #f2f2f2;
        }
        .error-message {
            color: #d9534f;
            background-color: #f2dede;
            border: 1px solid #ebccd1;
            padding: 10px;
            border-radius: 4px;
            margin-top: 10px;
        }
        .status-message {
            padding: 10px;
            margin-top: 10px;
            border-radius: 4px;
            background-color: #d9edf7;
            border: 1px solid #bce8f1;
            color: #31708f;
        }
    </style>
</head>
<body>
    <h1>AI Malware Scanner</h1>
    
    <div class="container">
        <div class="card">
            <h2>Upload File for Scanning</h2>
            <form id="uploadForm" enctype="multipart/form-data">
                <input type="file" id="fileInput" name="file"><br>
                <button type="button" id="uploadButton" onclick="uploadFile()">Upload and Scan</button>
            </form>
            <div id="uploadProgress" class="progress-bar" style="display: none;">
                <div id="progressBar" class="progress">0%</div>
            </div>
            <div id="uploadError" class="error-message" style="display: none;"></div>
        </div>
        
        <div class="card">
            <h2>System Scanning</h2>
            <div class="button-row">
                <button id="systemScanButton" onclick="scanSystem()">Scan Full System</button>
                <button id="cDriveButton" onclick="scanDrive('C:\\')">Scan C Drive</button>
                <button id="dDriveButton" onclick="scanDrive('D:\\')">Scan D Drive</button>
                <button id="customDriveButton" onclick="scanCustomPath()">Scan Custom Path</button>
            </div>
            <div id="scanStatus" class="status-message" style="display: none;"></div>
            <div id="scanError" class="error-message" style="display: none;"></div>
        </div>
        
        <div id="resultContainer" class="result-section card">
            <h2>Scan Results</h2>
            
            <div id="summarySection">
                <h3>Summary</h3>
                <p>File: <span id="fileName"></span></p>
                <p>Combined Risk Score: <span id="riskScore"></span></p>
            </div>
            
            <div id="threatIntelSection">
                <h3>Threat Intelligence</h3>
                <div id="threatIntelLoading" style="display: none;">Checking threat intelligence sources...</div>
                <div id="threatIntelError" class="error-message" style="display: none;"></div>
                <div id="threatIntelResults" style="display: none;">
                    <p>Detection Ratio: <span id="detectionRatio"></span></p>
                    <p>First Seen: <span id="firstSeen"></span></p>
                    
                    <h4>Top Detections</h4>
                    <table id="detectionsTable">
                        <tr>
                            <th>Engine</th>
                            <th>Result</th>
                            <th>Category</th>
                        </tr>
                        <tbody id="detectionsTableBody"></tbody>
                    </table>
                </div>
                <div id="threatIntelNotFound" style="display: none;">
                    <p>This file has not been previously analyzed by VirusTotal.</p>
                </div>
            </div>
            
            <div id="staticSection">
                <h3>Static Analysis</h3>
                <p>Classification: <span id="staticClassification"></span></p>
                <p>Confidence: <span id="staticConfidence"></span></p>
                
                <h4>File Information</h4>
                <table id="fileInfoTable">
                    <tr>
                        <th>Property</th>
                        <th>Value</th>
                    </tr>
                </table>
            </div>
            
            <div id="dynamicSection">
                <h3>Dynamic Analysis</h3>
                <p>Risk Level: <span id="dynamicRiskLevel"></span></p>
                
                <h4>Suspicious Indicators</h4>
                <ul id="suspiciousIndicators"></ul>

                <h4>Network Activity</h4>
                <ul id="networkActivity"></ul>
                
                <h4>File Activity</h4>
                <ul id="fileActivity"></ul>
            </div>
        </div>
    </div>

    <script>
        // API endpoint base URL
        const API_URL = "http://127.0.0.1:8001";
        
        // Utility function to show an error message
        function showError(elementId, message) {
            const element = document.getElementById(elementId);
            element.textContent = message;
            element.style.display = "block";
        }
        
        // Utility function to hide an error message
        function hideError(elementId) {
            document.getElementById(elementId).style.display = "none";
        }
        
        // Utility function to show a status message
        function showStatus(message) {
            const statusElement = document.getElementById("scanStatus");
            statusElement.textContent = message;
            statusElement.style.display = "block";
        }
        
        // Utility function to disable buttons during operations
        function setButtonsDisabled(disabled) {
            document.getElementById("uploadButton").disabled = disabled;
            document.getElementById("systemScanButton").disabled = disabled;
            document.getElementById("cDriveButton").disabled = disabled;
            document.getElementById("dDriveButton").disabled = disabled;
            document.getElementById("customDriveButton").disabled = disabled;
        }
        
        // Check if the API server is running when the page loads
        window.addEventListener('DOMContentLoaded', async () => {
            try {
                const pingResponse = await fetch(`${API_URL}/ping`, { 
                    method: "GET",
                    headers: {
                        "Accept": "application/json"
                    },
                    mode: "cors"
                });
                
                if (pingResponse.ok) {
                    const data = await pingResponse.json();
                    console.log("API server status:", data);
                    showStatus("API server is running and connected.");
                } else {
                    console.error("Server not responding correctly:", pingResponse.status);
                    showError("uploadError", `Server responded with status ${pingResponse.status}. Please restart the API server.`);
                }
            } catch (error) {
                console.error("API server connection error:", error);
                showError("uploadError", `Cannot connect to the scanning server at ${API_URL}. Please make sure the server is running.
                    Try running 'python -m api.server' in your terminal and ensure no firewall is blocking the connection.`);
            }
        });
        
        // Function to upload and scan a file
        async function uploadFile() {
            hideError("uploadError");
            
            const fileInput = document.getElementById("fileInput");
            if (!fileInput.files.length) {
                showError("uploadError", "Please select a file to upload");
                return;
            }
            
            // Disable buttons during upload
            setButtonsDisabled(true);
            
            // Show progress bar
            const progressBar = document.getElementById("progressBar");
            const uploadProgress = document.getElementById("uploadProgress");
            uploadProgress.style.display = "block";
            progressBar.style.width = "0%";
            progressBar.textContent = "0%";
            
            // Create form data for file upload
            const formData = new FormData();
            formData.append("file", fileInput.files[0]);
            
            try {
                // Simulate progress (actual progress isn't available in fetch API)
                let progress = 0;
                const progressInterval = setInterval(() => {
                    progress += 5;
                    if (progress > 90) {
                        clearInterval(progressInterval);
                    }
                    progressBar.style.width = progress + "%";
                    progressBar.textContent = progress + "%";
                }, 300);
                
                // Check if the server is available first
                try {
                    const pingResponse = await fetch(`${API_URL}/ping`, { 
                        method: "GET",
                        headers: {
                            "Accept": "application/json"
                        },
                        mode: "cors"
                    });
                    
                    if (!pingResponse.ok) {
                        throw new Error(`Server unavailable: ${pingResponse.status}`);
                    }
                } catch (pingError) {
                    console.error("Server ping error:", pingError);
                    showError("uploadError", `Cannot connect to the scanning server at ${API_URL}. Please make sure the server is running.
                        Try running 'python -m api.server' in your terminal and restart your browser.`);
                    clearInterval(progressInterval);
                    uploadProgress.style.display = "none";
                    setButtonsDisabled(false);
                    return;
                }
                
                // Send API request
                const response = await fetch(`${API_URL}/upload`, {
                    method: "POST",
                    body: formData,
                    mode: "cors"
                });
                
                // Clear progress simulation
                clearInterval(progressInterval);
                progressBar.style.width = "100%";
                progressBar.textContent = "100%";
                
                // Parse response
                const result = await response.json();
                
                // Check for error
                if (result.error) {
                    showError("uploadError", `Error: ${result.error}`);
                    uploadProgress.style.display = "none";
                    setButtonsDisabled(false);
                    return;
                }
                
                // Display results
                displayResults(result);
                
                // If we have hash values, query threat intelligence
                if (result.static_analysis && 
                    result.static_analysis.features && 
                    (result.static_analysis.features.md5 || result.static_analysis.features.sha256)) {
                    
                    const fileHash = result.static_analysis.features.sha256 || result.static_analysis.features.md5;
                    queryThreatIntelligence(fileHash);
                }
                
                // Hide progress bar after a short delay
                setTimeout(() => {
                    uploadProgress.style.display = "none";
                    setButtonsDisabled(false);
                }, 1000);
                
            } catch (error) {
                console.error("Upload error:", error);
                showError("uploadError", `Error: ${error.message || "Failed to upload file"}. Please ensure the API server is running.`);
                uploadProgress.style.display = "none";
                setButtonsDisabled(false);
            }
        }
        
        // Function to scan the entire system
        async function scanSystem() {
            hideError("scanError");
            setButtonsDisabled(true);
            
            showStatus("Starting system scan...");
            
            try {
                const response = await fetch(`${API_URL}/scan/system`, {
                    method: "POST",
                    headers: {
                        "Content-Type": "application/json"
                    }
                });
                
                const result = await response.json();
                
                if (result.error) {
                    showError("scanError", `Error: ${result.error}`);
                    setButtonsDisabled(false);
                    return;
                }
                
                showStatus(result.message || "System scan started successfully. Check logs for details.");
                
                // Start polling for status
                pollScanStatus();
                
            } catch (error) {
                console.error("System scan error:", error);
                showError("scanError", `Error: ${error.message || "Failed to start system scan"}`);
                setButtonsDisabled(false);
            }
        }
        
        // Function to scan a specific drive
        async function scanDrive(drivePath) {
            if (!drivePath) return;
            
            hideError("scanError");
            setButtonsDisabled(true);
            
            showStatus(`Starting scan of ${drivePath}...`);
            
            try {
                const response = await fetch(`${API_URL}/scan/drive`, {
                    method: "POST",
                    headers: {
                        "Content-Type": "application/json"
                    },
                    body: JSON.stringify({
                        path: drivePath,
                        recursive: true
                    })
                });
                
                const result = await response.json();
                
                if (result.error) {
                    showError("scanError", `Error: ${result.error}`);
                    setButtonsDisabled(false);
                    return;
                }
                
                showStatus(result.message || `Scan of ${drivePath} started successfully. Check logs for details.`);
                
                // Start polling for status
                pollScanStatus();
                
            } catch (error) {
                console.error(`Drive scan error for ${drivePath}:`, error);
                showError("scanError", `Error: ${error.message || `Failed to scan ${drivePath}`}`);
                setButtonsDisabled(false);
            }
        }
        
        // Function to scan a custom path
        function scanCustomPath() {
            const path = prompt("Enter path to scan:");
            if (path) {
                scanDrive(path);
            }
        }
        
        // Function to poll for scan status
        function pollScanStatus() {
            let statusCheckInterval = setInterval(async () => {
                try {
                    const response = await fetch(`${API_URL}/scan/status`);
                    const result = await response.json();
                    
                    if (result.error) {
                        console.error("Status check error:", result.error);
                        clearInterval(statusCheckInterval);
                        setButtonsDisabled(false);
                        return;
                    }
                    
                    const stats = result.stats || {};
                    
                    // Format the status message
                    let statusMsg = `Scan status: ${result.status}\n`;
                    
                    if (stats.total_files !== undefined) {
                        statusMsg += `Files found: ${stats.total_files}, `;
                        statusMsg += `Scanned: ${stats.scanned_files || stats.total_files}, `;
                        statusMsg += `Malicious: ${stats.malicious_files || 0}, `;
                        statusMsg += `Errors: ${stats.error_files || 0}`;
                    }
                    
                    // Display suspicious files if available
                    if (result.suspicious_files && result.suspicious_files.length > 0) {
                        statusMsg += `\n\nSuspicious Files (showing ${result.suspicious_files.length}):\n`;
                        
                        // Create a list of suspicious files
                        const suspiciousList = document.createElement('ul');
                        suspiciousList.style.marginTop = '10px';
                        suspiciousList.style.listStyleType = 'none';
                        suspiciousList.style.padding = '0';
                        
                        result.suspicious_files.slice(0, 10).forEach(file => {
                            const listItem = document.createElement('li');
                            listItem.style.marginBottom = '5px';
                            listItem.style.padding = '5px';
                            listItem.style.backgroundColor = '#ffeeee';
                            listItem.style.borderRadius = '3px';
                            
                            // Format file size
                            let sizeText = "";
                            if (file.size > 1024 * 1024) {
                                sizeText = `${(file.size / (1024 * 1024)).toFixed(2)} MB`;
                            } else if (file.size > 1024) {
                                sizeText = `${(file.size / 1024).toFixed(2)} KB`;
                            } else {
                                sizeText = `${file.size} bytes`;
                            }
                            
                            listItem.textContent = `${file.path} (${sizeText}, ${file.type})`;
                            suspiciousList.appendChild(listItem);
                        });
                        
                        // Add "show more" if there are more than 10 files
                        if (result.suspicious_files.length > 10) {
                            const moreItem = document.createElement('li');
                            moreItem.style.textAlign = 'center';
                            moreItem.style.marginTop = '5px';
                            moreItem.textContent = `...and ${result.suspicious_files.length - 10} more suspicious files`;
                            suspiciousList.appendChild(moreItem);
                        }
                        
                        // Clear existing status first
                        const statusElement = document.getElementById("scanStatus");
                        statusElement.textContent = statusMsg;
                        statusElement.appendChild(suspiciousList);
                        statusElement.style.display = "block";
                    } else {
                        showStatus(statusMsg);
                    }
                    
                    // If scan is complete, stop polling
                    if (result.status !== "running") {
                        clearInterval(statusCheckInterval);
                        setButtonsDisabled(false);
                    }
                    
                } catch (error) {
                    console.error("Status check error:", error);
                    // Don't stop polling on error, try again
                }
            }, 3000); // Check every 3 seconds
            
            // Safety timeout to stop polling after 5 minutes
            setTimeout(() => {
                clearInterval(statusCheckInterval);
                setButtonsDisabled(false);
                showStatus("Scan may still be running in the background. Check logs for details.");
            }, 5 * 60 * 1000);
        }
        
        // Function to display scan results
        function displayResults(result) {
            // Show results container
            document.getElementById("resultContainer").style.display = "block";
            
            // Display file name
            document.getElementById("fileName").innerText = result.filename || "Unknown file";
            
            // Display risk score
            const riskScoreElement = document.getElementById("riskScore");
            const riskScore = result.combined_risk_score || 0;
            
            if (riskScore > 0.7) {
                riskScoreElement.innerHTML = `<span class="risk-high">${riskScore.toFixed(2)} (High)</span>`;
            } else if (riskScore > 0.4) {
                riskScoreElement.innerHTML = `<span class="risk-medium">${riskScore.toFixed(2)} (Medium)</span>`;
            } else {
                riskScoreElement.innerHTML = `<span class="risk-low">${riskScore.toFixed(2)} (Low)</span>`;
            }
            
            // Display static analysis results
            const staticAnalysis = result.static_analysis || {};
            const staticResult = staticAnalysis.prediction || {};
            
            document.getElementById("staticClassification").innerText = staticResult.label || "Unknown";
            document.getElementById("staticConfidence").innerText = 
                typeof staticResult.confidence === 'number' ? staticResult.confidence.toFixed(2) : "N/A";
            
            // Display file information
            const fileInfoTable = document.getElementById("fileInfoTable");
            fileInfoTable.innerHTML = "<tr><th>Property</th><th>Value</th></tr>";
            
            const features = staticAnalysis.features || {};
            const relevantProperties = [
                'file_size', 'file_type', 'md5', 'sha256', 'entropy'
            ];
            
            for (const prop of relevantProperties) {
                if (features[prop] !== undefined) {
                    const row = fileInfoTable.insertRow();
                    const cell1 = row.insertCell(0);
                    const cell2 = row.insertCell(1);
                    cell1.textContent = prop;
                    
                    // Format file size nicely
                    if (prop === 'file_size') {
                        const size = features[prop];
                        let sizeText;
                        if (size > 1024 * 1024) {
                            sizeText = `${(size / (1024 * 1024)).toFixed(2)} MB`;
                        } else if (size > 1024) {
                            sizeText = `${(size / 1024).toFixed(2)} KB`;
                        } else {
                            sizeText = `${size} bytes`;
                        }
                        cell2.textContent = sizeText;
                    } else {
                        cell2.textContent = features[prop];
                    }
                }
            }
            
            // Display dynamic analysis results
            const dynamicResult = result.dynamic_analysis || {};
            const dynamicRiskElement = document.getElementById("dynamicRiskLevel");
            const riskLevel = dynamicResult.risk_level || "Low";
            
            if (riskLevel === "High") {
                dynamicRiskElement.innerHTML = `<span class="risk-high">${riskLevel}</span>`;
            } else if (riskLevel === "Medium") {
                dynamicRiskElement.innerHTML = `<span class="risk-medium">${riskLevel}</span>`;
            } else {
                dynamicRiskElement.innerHTML = `<span class="risk-low">${riskLevel}</span>`;
            }
            
            // Display suspicious indicators
            const indicatorsList = document.getElementById("suspiciousIndicators");
            indicatorsList.innerHTML = "";
            
            if (dynamicResult.suspicious_indicators && dynamicResult.suspicious_indicators.length > 0) {
                for (const indicator of dynamicResult.suspicious_indicators) {
                    const li = document.createElement("li");
                    li.textContent = indicator;
                    indicatorsList.appendChild(li);
                }
            } else {
                indicatorsList.innerHTML = "<li>No suspicious indicators found</li>";
            }
            
            // Display network activity
            const networkList = document.getElementById("networkActivity");
            networkList.innerHTML = "";
            
            if (dynamicResult.network_connections && dynamicResult.network_connections.length > 0) {
                for (const connection of dynamicResult.network_connections) {
                    const li = document.createElement("li");
                    li.textContent = connection;
                    networkList.appendChild(li);
                }
            } else {
                networkList.innerHTML = "<li>No network activity detected</li>";
            }
            
            // Display file activity
            const fileList = document.getElementById("fileActivity");
            fileList.innerHTML = "";
            
            if (dynamicResult.file_activity && dynamicResult.file_activity.length > 0) {
                for (const file of dynamicResult.file_activity) {
                    const li = document.createElement("li");
                    li.textContent = file;
                    fileList.appendChild(li);
                }
            } else {
                fileList.innerHTML = "<li>No file activity detected</li>";
            }
        }
        
        // Function to query threat intelligence for a file hash
        async function queryThreatIntelligence(fileHash) {
            if (!fileHash) return;
            
            // Show loading indicator
            document.getElementById("threatIntelSection").style.display = "block";
            document.getElementById("threatIntelLoading").style.display = "block";
            document.getElementById("threatIntelError").style.display = "none";
            document.getElementById("threatIntelResults").style.display = "none";
            document.getElementById("threatIntelNotFound").style.display = "none";
            
            try {
                const response = await fetch(`${API_URL}/threat-intel`, {
                    method: "POST",
                    headers: {
                        "Content-Type": "application/json"
                    },
                    body: JSON.stringify({ file_hash: fileHash })
                });
                
                const result = await response.json();
                
                // Hide loading indicator
                document.getElementById("threatIntelLoading").style.display = "none";
                
                if (result.error) {
                    // Show error message
                    const errorElement = document.getElementById("threatIntelError");
                    errorElement.textContent = result.error;
                    errorElement.style.display = "block";
                    return;
                }
                
                if (result.status === "not_found") {
                    // Show not found message
                    document.getElementById("threatIntelNotFound").style.display = "block";
                    return;
                }
                
                if (result.status === "success" && result.summary) {
                    // Show results
                    const resultsElement = document.getElementById("threatIntelResults");
                    resultsElement.style.display = "block";
                    
                    // Fill in detection info
                    document.getElementById("detectionRatio").textContent = result.summary.detection_ratio;
                    
                    // Format dates if they're timestamps
                    let firstSeen = result.summary.file_info.first_seen;
                    if (typeof firstSeen === 'number' && firstSeen > 0) {
                        firstSeen = new Date(firstSeen * 1000).toLocaleString();
                    }
                    document.getElementById("firstSeen").textContent = firstSeen;
                    
                    // Fill in detections table
                    const tableBody = document.getElementById("detectionsTableBody");
                    tableBody.innerHTML = "";
                    
                    if (result.summary.top_detections && result.summary.top_detections.length > 0) {
                        for (const detection of result.summary.top_detections) {
                            const row = tableBody.insertRow();
                            
                            const engineCell = row.insertCell(0);
                            engineCell.textContent = detection.engine;
                            
                            const resultCell = row.insertCell(1);
                            resultCell.textContent = detection.result;
                            
                            const categoryCell = row.insertCell(2);
                            if (detection.category === "malicious") {
                                categoryCell.innerHTML = `<span class="risk-high">${detection.category}</span>`;
                            } else if (detection.category === "suspicious") {
                                categoryCell.innerHTML = `<span class="risk-medium">${detection.category}</span>`;
                            } else {
                                categoryCell.textContent = detection.category;
                            }
                        }
                    } else {
                        const row = tableBody.insertRow();
                        const cell = row.insertCell(0);
                        cell.colSpan = 3;
                        cell.textContent = "No detections available";
                    }
                }
                
            } catch (error) {
                console.error("Threat intelligence error:", error);
                
                // Show error message
                const errorElement = document.getElementById("threatIntelError");
                errorElement.textContent = `Failed to get threat intelligence: ${error.message || "Unknown error"}`;
                errorElement.style.display = "block";
                
                // Hide loading indicator
                document.getElementById("threatIntelLoading").style.display = "none";
            }
        }
    </script>
</body>
</html>
